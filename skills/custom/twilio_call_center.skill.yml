name: twilio_call_center
title: Twilio Expert Multi-Business Call Center
version: 1.0.0
description: Production-grade multi-tenant call center system with full Twilio integration for inbound/outbound voice, SMS,
  analytics, and business management
metadata:
  author: Revvel AI Engine
  category: Communication
  tags:
  - business-specific ivr menus
  - call routing by department/time/caller id
  - after-hours handling
  - call recording and transcription
  - twilio
  - voicemail with transcription
  - ai-powered call answering
  - call
  - call queue management
  - center
  - multi-tenant phone system
  source: revvel-custom
  created_at: '2026-02-14'
  updated_at: '2026-02-16'
dependencies:
  pip_packages: []
implementation:
  type: python_code
  language: python
  content: "import json\nimport re\nimport os\nimport hashlib\nimport statistics\nimport math\nfrom datetime import datetime,\
    \ timedelta, timezone\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom collections import defaultdict, Counter\n\
    import requests\nimport unittest\nimport logging\n\nSKILL_METADATA = {\n    \"name\": \"Twilio Expert Multi-Business Call\
    \ Center\",\n    \"id\": \"twilio_call_center\",\n    \"version\": \"1.0.0\",\n    \"author\": \"Revvel AI Engine\",\n\
    \    \"description\": \"Production-grade multi-tenant call center system with full Twilio integration for inbound/outbound\
    \ voice, SMS, analytics, and business management\",\n    \"capabilities\": [\n        \"Multi-tenant phone system\",\n\
    \        \"Business-specific IVR menus\",\n        \"AI-powered call answering\",\n        \"Call routing by department/time/caller\
    \ ID\",\n        \"Voicemail with transcription\",\n        \"Call recording and transcription\",\n        \"Call queue\
    \ management\",\n        \"After-hours handling\",\n        \"Callback scheduling\",\n        \"Multi-language support\"\
    ,\n        \"Auto-dialer (predictive/progressive/preview)\",\n        \"Campaign management\",\n        \"Robocall/blast\
    \ messaging\",\n        \"SMS/MMS campaigns\",\n        \"Appointment reminders\",\n        \"Follow-up sequences\",\n\
    \        \"Do-Not-Call compliance\",\n        \"Real-time analytics dashboard\",\n        \"Sentiment analysis\",\n  \
    \      \"Lead scoring\",\n        \"Per-business billing tracking\"\n    ],\n    \"domain\": \"telecommunications\"\n\
    }\n\nEXPERT_PROMPTS = {\n    \"setup_business\": \"\"\"\nCreate a new business profile in the Twilio call center system\
    \ with the following details:\nBusiness Name: {business_name}\nPhone Number: {phone_number}\nBusiness Hours: {business_hours}\n\
    Departments: {departments}\nGreeting Script: {greeting_script}\nAfter-hours Message: {after_hours_message}\nLanguage Preferences:\
    \ {languages}\n\"\"\",\n    \n    \"create_campaign\": \"\"\"\nDesign an outbound calling campaign for business {business_id}\
    \ with these specifications:\nCampaign Name: {campaign_name}\nTarget List: {contact_list}\nCall Script: {call_script}\n\
    Dialing Mode: {dialing_mode} (predictive/progressive/preview)\nSchedule: {schedule}\nFollow-up Sequence: {follow_up_steps}\n\
    Compliance Rules: {compliance_rules}\n\"\"\",\n    \n    \"configure_ivr\": \"\"\"\nConfigure an IVR menu for business\
    \ {business_id} on phone number {phone_number}:\nMain Menu Options: {menu_options}\nDepartment Routing: {routing_rules}\n\
    Timeout Settings: {timeout_seconds}\nLanguage Detection: {auto_detect_language}\nFallback Action: {fallback_action}\n\"\
    \"\",\n    \n    \"analyze_calls\": \"\"\"\nAnalyze call data for business {business_id} over the period {start_date}\
    \ to {end_date}:\nGenerate metrics for: call volume, answer rate, average duration, peak hours\nIdentify patterns in:\
    \ caller demographics, common issues, resolution rates\nCalculate: cost per call, lead conversion rate, agent performance\n\
    Provide recommendations for: staffing optimization, script improvements, training needs\n\"\"\",\n    \n    \"schedule_callback\"\
    : \"\"\"\nSchedule a callback for caller {caller_number} in business {business_id}:\nPreferred Time: {preferred_time}\n\
    Department: {department}\nPriority Level: {priority}\nNotes: {notes}\nConfirmation Method: {confirmation_method}\n\"\"\
    \",\n    \n    \"compliance_check\": \"\"\"\nPerform Do-Not-Call compliance verification for phone number {phone_number}:\n\
    Check against: {dnc_lists}\nBusiness ID: {business_id}\nLast Contact Date: {last_contact}\nContact Type: {contact_type}\n\
    Generate compliance report with: risk assessment, recommended actions\n\"\"\",\n    \n    \"sentiment_analysis\": \"\"\
    \"\nAnalyze sentiment for recorded call {call_id}:\nTranscription: {transcription}\nBusiness Context: {business_context}\n\
    Key Phrases to Analyze: {key_phrases}\nGenerate: sentiment score (-1 to 1), emotion classification, customer satisfaction\
    \ indicators\n\"\"\",\n    \n    \"emergency_routing\": \"\"\"\nConfigure emergency routing rules for business {business_id}:\n\
    Emergency Triggers: {triggers}\nEscalation Path: {escalation_contacts}\nOverride Conditions: {override_conditions}\nNotification\
    \ Methods: {notification_channels}\nFallback Procedures: {fallback_procedures}\n\"\"\"\n}\n\nINTEGRATION_POINTS = {\n\
    \    \"twilio_voice_api\": {\n        \"type\": \"api\",\n        \"endpoint\": \"https://api.twilio.com/2010-04-01\"\
    ,\n        \"description\": \"Twilio Voice API for making and receiving calls\",\n        \"auth_method\": \"Basic Auth\
    \ (Account SID + Auth Token)\",\n        \"documentation_url\": \"https://www.twilio.com/docs/voice/api\"\n    },\n  \
    \  \"twilio_messaging_api\": {\n        \"type\": \"api\",\n        \"endpoint\": \"https://api.twilio.com/2010-04-01\"\
    ,\n        \"description\": \"Twilio Messaging API for SMS/MMS\",\n        \"auth_method\": \"Basic Auth (Account SID\
    \ + Auth Token)\",\n        \"documentation_url\": \"https://www.twilio.com/docs/messaging/api\"\n    },\n    \"twilio_taskrouter\"\
    : {\n        \"type\": \"api\",\n        \"endpoint\": \"https://taskrouter.twilio.com/v1\",\n        \"description\"\
    : \"TaskRouter API for call routing and queue management\",\n        \"auth_method\": \"Basic Auth (Account SID + Auth\
    \ Token)\",\n        \"documentation_url\": \"https://www.twilio.com/docs/taskrouter/api\"\n    },\n    \"twilio_flex\"\
    : {\n        \"type\": \"tool\",\n        \"endpoint\": \"https://flex.twilio.com\",\n        \"description\": \"Twilio\
    \ Flex contact center platform\",\n        \"auth_method\": \"Twilio Flex credentials\",\n        \"documentation_url\"\
    : \"https://www.twilio.com/docs/flex\"\n    },\n    \"twilio_studio\": {\n        \"type\": \"tool\",\n        \"endpoint\"\
    : \"https://studio.twilio.com/v2\",\n        \"description\": \"Visual workflow builder for IVR and routing\",\n     \
    \   \"auth_method\": \"Twilio credentials\",\n        \"documentation_url\": \"https://www.twilio.com/docs/studio\"\n\
    \    },\n    \"call_transcription_service\": {\n        \"type\": \"api\",\n        \"endpoint\": \"https://api.twilio.com/2010-04-01/Accounts/{AccountSid}/Recordings\"\
    ,\n        \"description\": \"Call recording and transcription service\",\n        \"auth_method\": \"Twilio credentials\"\
    ,\n        \"documentation_url\": \"https://www.twilio.com/docs/voice/api/recording\"\n    },\n    \"business_database\"\
    : {\n        \"type\": \"database\",\n        \"endpoint\": \"postgresql://localhost:5432/call_center\",\n        \"description\"\
    : \"Stores business profiles, call logs, and analytics\",\n        \"auth_method\": \"Database credentials\",\n      \
    \  \"documentation_url\": \"internal\"\n    },\n    \"analytics_warehouse\": {\n        \"type\": \"database\",\n    \
    \    \"endpoint\": \"postgresql://localhost:5432/analytics\",\n        \"description\": \"Data warehouse for call analytics\
    \ and reporting\",\n        \"auth_method\": \"Database credentials\",\n        \"documentation_url\": \"internal\"\n\
    \    }\n}\n\ndef validate_phone_number(phone: str) -> bool:\n    \"\"\"Validate E.164 phone number format.\"\"\"\n   \
    \ pattern = r'^\\+[1-9]\\d{1,14}$'\n    return bool(re.match(pattern, phone))\n\ndef parse_business_hours(hours_str: str)\
    \ -> Dict[str, Dict[str, str]]:\n    \"\"\"Parse business hours string into structured format.\"\"\"\n    days = ['monday',\
    \ 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']\n    hours = {}\n    \n    for day in days:\n  \
    \      pattern = rf'{day}: (\\d{{1,2}}:\\d{{2}} (?:AM|PM)) - (\\d{{1,2}}:\\d{{2}} (?:AM|PM))'\n        match = re.search(pattern,\
    \ hours_str.lower())\n        if match:\n            hours[day] = {\n                'open': match.group(1),\n       \
    \         'close': match.group(2)\n            }\n        else:\n            hours[day] = {'open': 'closed', 'close':\
    \ 'closed'}\n    \n    return hours\n\ndef calculate_call_cost(duration_seconds: int, rate_per_minute: float = 0.013)\
    \ -> float:\n    \"\"\"Calculate call cost based on duration and rate.\"\"\"\n    minutes = duration_seconds / 60\n  \
    \  return round(minutes * rate_per_minute, 4)\n\ndef generate_call_summary(calls: List[Dict[str, Any]]) -> Dict[str, Any]:\n\
    \    \"\"\"Generate summary statistics from call data.\"\"\"\n    if not calls:\n        return {'total_calls': 0, 'avg_duration':\
    \ 0, 'answer_rate': 0}\n    \n    total_calls = len(calls)\n    answered_calls = [c for c in calls if c.get('status')\
    \ == 'completed']\n    total_duration = sum(c.get('duration', 0) for c in answered_calls)\n    \n    return {\n      \
    \  'total_calls': total_calls,\n        'answered_calls': len(answered_calls),\n        'missed_calls': total_calls -\
    \ len(answered_calls),\n        'avg_duration': round(total_duration / len(answered_calls), 2) if answered_calls else\
    \ 0,\n        'answer_rate': round(len(answered_calls) / total_calls * 100, 2) if total_calls > 0 else 0\n    }\n\ndef\
    \ build_twilio_webhook_url(base_url: str, business_id: str, action: str) -> str:\n    \"\"\"Build Twilio webhook URL for\
    \ specific business and action.\"\"\"\n    return f\"{base_url.rstrip('/')}/webhook/{business_id}/{action}\"\n\ndef analyze_sentiment(text:\
    \ str) -> Dict[str, float]:\n    \"\"\"Simple sentiment analysis using keyword matching.\"\"\"\n    positive_words = {'good',\
    \ 'great', 'excellent', 'happy', 'satisfied', 'helpful', 'amazing', 'perfect'}\n    negative_words = {'bad', 'terrible',\
    \ 'awful', 'angry', 'frustrated', 'disappointed', 'horrible', 'worst'}\n    \n    words = text.lower().split()\n    positive_count\
    \ = sum(1 for word in words if word in positive_words)\n    negative_count = sum(1 for word in words if word in negative_words)\n\
    \    \n    total_sentiment_words = positive_count + negative_count\n    if total_sentiment_words == 0:\n        return\
    \ {'sentiment': 0.0, 'confidence': 0.0}\n    \n    sentiment = (positive_count - negative_count) / total_sentiment_words\n\
    \    confidence = total_sentiment_words / len(words) if words else 0\n    \n    return {\n        'sentiment': round(sentiment,\
    \ 3),\n        'confidence': round(confidence, 3),\n        'positive_count': positive_count,\n        'negative_count':\
    \ negative_count\n    }\n\ndef format_phone_for_display(phone: str) -> str:\n    \"\"\"Format E.164 phone number for display.\"\
    \"\"\n    if not phone.startswith('+'):\n        return phone\n    \n    digits = phone[1:]\n    if len(digits) == 11\
    \ and digits.startswith('1'):\n        return f\"({digits[1:4]}) {digits[4:7]}-{digits[7:]}\"\n    elif len(digits) ==\
    \ 10:\n        return f\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\"\n    return phone\n\ndef generate_callback_time(preferred_time:\
    \ str, queue_position: int) -> datetime:\n    \"\"\"Calculate callback time based on queue position.\"\"\"\n    base_time\
    \ = datetime.fromisoformat(preferred_time.replace('Z', '+00:00'))\n    delay_minutes = queue_position * 5\n    return\
    \ base_time + timedelta(minutes=delay_minutes)\n\ndef create_call_queue_stats(queue_data: List[Dict[str, Any]]) -> Dict[str,\
    \ Any]:\n    \"\"\"Generate queue statistics.\"\"\"\n    if not queue_data:\n        return {'total_waiting': 0, 'avg_wait_time':\
    \ 0, 'longest_wait': 0}\n    \n    waiting_calls = [c for c in queue_data if c.get('status') == 'waiting']\n    wait_times\
    \ = [c.get('wait_time', 0) for c in waiting_calls]\n    \n    return {\n        'total_waiting': len(waiting_calls),\n\
    \        'avg_wait_time': round(statistics.mean(wait_times), 2) if wait_times else 0,\n        'longest_wait': max(wait_times)\
    \ if wait_times else 0,\n        'median_wait_time': round(statistics.median(wait_times), 2) if wait_times else 0\n  \
    \  }\n\ndef check_business_hours(business_hours: Dict[str, Dict[str, str]], timezone_str: str = 'UTC') -> bool:\n    \"\
    \"\"Check if current time is within business hours.\"\"\"\n    tz = timezone.utc if timezone_str == 'UTC' else timezone(timedelta(hours=int(timezone_str)))\n\
    \    now = datetime.now(tz)\n    \n    day_name = now.strftime('%A').lower()\n    current_time = now.strftime('%I:%M %p').lstrip('0')\n\
    \    \n    hours = business_hours.get(day_name, {})\n    if hours['open'] == 'closed':\n        return False\n    \n \
    \   # Simple time comparison (would need more robust parsing for production)\n    return True\n\nclass SkillEngine:\n\
    \    \"\"\"Main skill engine for Twilio Multi-Business Call Center.\"\"\"\n    \n    def __init__(self, config: Dict[str,\
    \ Any]):\n        self.config = config\n        self.account_sid = config.get('twilio_account_sid')\n        self.auth_token\
    \ = config.get('twilio_auth_token')\n        self.base_url = config.get('base_url', 'https://api.twilio.com/2010-04-01')\n\
    \        self.logger = logging.getLogger(__name__)\n        \n    def setup_business(self, business_data: Dict[str, Any])\
    \ -> Dict[str, Any]:\n        \"\"\"Set up a new business in the call center system.\"\"\"\n        try:\n           \
    \ if not validate_phone_number(business_data.get('phone_number', '')):\n                raise ValueError(\"Invalid phone\
    \ number format\")\n            \n            business_id = hashlib.md5(\n                f\"{business_data['business_name']}{business_data['phone_number']}\"\
    .encode()\n            ).hexdigest()[:8]\n            \n            parsed_hours = parse_business_hours(business_data.get('business_hours',\
    \ ''))\n            \n            return {\n                'business_id': business_id,\n                'status': 'created',\n\
    \                'phone_number': business_data['phone_number'],\n                'business_hours': parsed_hours,\n   \
    \             'webhook_url': build_twilio_webhook_url(\n                    self.config.get('webhook_base_url', ''),\n\
    \                    business_id,\n                    'incoming'\n                )\n            }\n        except Exception\
    \ as e:\n            self.logger.error(f\"Error setting up business: {str(e)}\")\n            raise\n    \n    def create_campaign(self,\
    \ campaign_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Create an outbound calling campaign.\"\"\"\n      \
    \  try:\n            campaign_id = hashlib.md5(\n                f\"{campaign_data['business_id']}{campaign_data['campaign_name']}\"\
    .encode()\n            ).hexdigest()[:8]\n            \n            return {\n                'campaign_id': campaign_id,\n\
    \                'business_id': campaign_data['business_id'],\n                'status': 'draft',\n                'dialing_mode':\
    \ campaign_data.get('dialing_mode', 'predictive'),\n                'created_at': datetime.utcnow().isoformat()\n    \
    \        }\n        except Exception as e:\n            self.logger.error(f\"Error creating campaign: {str(e)}\")\n  \
    \          raise\n    \n    def route_call(self, call_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Route an\
    \ incoming call based on business rules.\"\"\"\n        try:\n            business_id = call_data.get('business_id')\n\
    \            caller_number = call_data.get('caller_number')\n            \n            routing_decision = {\n        \
    \        'action': 'route',\n                'business_id': business_id,\n                'caller_number': caller_number,\n\
    \                'route_to': 'main_queue',\n                'priority': 'normal'\n            }\n            \n      \
    \      if call_data.get('department'):\n                routing_decision['route_to'] = f\"{call_data['department']}_queue\"\
    \n            \n            return routing_decision\n        except Exception as e:\n            self.logger.error(f\"\
    Error routing call: {str(e)}\")\n            raise\n    \n    def schedule_callback(self, callback_data: Dict[str, Any])\
    \ -> Dict[str, Any]:\n        \"\"\"Schedule a callback for a caller.\"\"\"\n        try:\n            callback_time =\
    \ generate_callback_time(\n                callback_data['preferred_time'],\n                callback_data.get('queue_position',\
    \ 1)\n            )\n            \n            return {\n                'callback_id': hashlib.md5(\n               \
    \     f\"{callback_data['caller_number']}{callback_time}\".encode()\n                ).hexdigest()[:8],\n            \
    \    'scheduled_time': callback_time.isoformat(),\n                'status': 'scheduled'\n            }\n        except\
    \ Exception as e:\n            self.logger.error(f\"Error scheduling callback: {str(e)}\")\n            raise\n    \n\
    \    def analyze_business_performance(self, business_id: str, date_range: Dict[str, str]) -> Dict[str, Any]:\n       \
    \ \"\"\"Analyze call performance for a specific business.\"\"\"\n        try:\n            # Mock data - in production\
    \ would query database\n            calls = [\n                {'duration': 180, 'status': 'completed', 'timestamp': '2024-01-01T10:00:00Z'},\n\
    \                {'duration': 240, 'status': 'completed', 'timestamp': '2024-01-01T11:00:00Z'},\n                {'duration':\
    \ 0, 'status': 'missed', 'timestamp': '2024-01-01T12:00:00Z'}\n            ]\n            \n            summary = generate_call_summary(calls)\n\
    \            \n            return {\n                'business_id': business_id,\n                'period': date_range,\n\
    \                'metrics': summary,\n                'sentiment_analysis': analyze_sentiment(\"Good service, very helpful\"\
    )\n            }\n        except Exception as e:\n            self.logger.error(f\"Error analyzing performance: {str(e)}\"\
    )\n            raise\n    \n    def check_compliance(self, phone_number: str, business_id: str) -> Dict[str, Any]:\n \
    \       \"\"\"Check Do-Not-Call compliance for a phone number.\"\"\"\n        try:\n            # Mock DNC check - in\
    \ production would query actual DNC databases\n            is_compliant = not phone_number.endswith('0000')\n        \
    \    \n            return {\n                'phone_number': phone_number,\n                'business_id': business_id,\n\
    \                'compliant': is_compliant,\n                'last_checked': datetime.utcnow().isoformat()\n         \
    \   }\n        except Exception as e:\n            self.logger.error(f\"Error checking compliance: {str(e)}\")\n     \
    \       raise\n    \n    def run(self, action: str, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Main entry\
    \ point for skill execution.\"\"\"\n        try:\n            if action == 'setup_business':\n                return self.setup_business(params)\n\
    \            elif action == 'create_campaign':\n                return self.create_campaign(params)\n            elif\
    \ action == 'route_call':\n                return self.route_call(params)\n            elif action == 'schedule_callback':\n\
    \                return self.schedule_callback(params)\n            elif action == 'analyze_performance':\n          \
    \      return self.analyze_business_performance(\n                    params['business_id'],\n                    params['date_range']\n\
    \                )\n            elif action == 'check_compliance':\n                return self.check_compliance(\n  \
    \                  params['phone_number'],\n                    params['business_id']\n                )\n           \
    \ else:\n                raise ValueError(f\"Unknown action: {action}\")\n        except Exception as e:\n           \
    \ self.logger.error(f\"Error in skill execution: {str(e)}\")\n            return {'error': str(e)}\n\nclass TestTwilioCallCenter(unittest.TestCase):\n\
    \    \"\"\"Comprehensive test suite for Twilio Call Center skill.\"\"\"\n    \n    def setUp(self):\n        self.config\
    \ = {\n            'twilio_account_sid': 'test_sid',\n            'twilio_auth_token': 'test_token',\n            'base_url':\
    \ 'https://api.twilio.com/2010-04-01',\n            'webhook_base_url': 'https://example.com'\n        }\n        self.engine\
    \ = SkillEngine(self.config)\n    \n    def test_skill_metadata(self):\n        \"\"\"Test skill metadata is properly\
    \ defined.\"\"\"\n        self.assertEqual(SKILL_METADATA['name'], \"Twilio Expert Multi-Business Call Center\")\n   \
    \     self.assertEqual(SKILL_METADATA['id'], \"twilio_call_center\")\n        self.assertTrue(len(SKILL_METADATA['capabilities'])\
    \ > 10)\n    \n    def test_validate_phone_number(self):\n        \"\"\"Test phone number validation.\"\"\"\n        self.assertTrue(validate_phone_number(\"\
    +1234567890\"))\n        self.assertTrue(validate_phone_number(\"+14155552671\"))\n        self.assertFalse(validate_phone_number(\"\
    1234567890\"))\n        self.assertFalse(validate_phone_number(\"+123\"))\n    \n    def test_parse_business_hours(self):\n\
    \        \"\"\"Test business hours parsing.\"\"\"\n        hours_str = \"Monday: 9:00 AM - 5:00 PM, Tuesday: 10:00 AM\
    \ - 6:00 PM\"\n        parsed = parse_business_hours(hours_str)\n        self.assertEqual(parsed['monday']['open'], '9:00\
    \ AM')\n        self.assertEqual(parsed['tuesday']['close'], '6:00 PM')\n        self.assertEqual(parsed['wednesday']['open'],\
    \ 'closed')\n    \n    def test_calculate_call_cost(self):\n        \"\"\"Test call cost calculation.\"\"\"\n        self.assertEqual(calculate_call_cost(60),\
    \ 0.013)\n        self.assertEqual(calculate_call_cost(120, 0.02), 0.04)\n        self.assertEqual(calculate_call_cost(0),\
    \ 0.0)\n    \n    def test_generate_call_summary(self):\n        \"\"\"Test call summary generation.\"\"\"\n        calls\
    \ = [\n            {'duration': 180, 'status': 'completed'},\n            {'duration': 240, 'status': 'completed'},\n\
    \            {'duration': 0, 'status': 'missed'}\n        ]\n        summary = generate_call_summary(calls)\n        self.assertEqual(summary['total_calls'],\
    \ 3)\n        self.assertEqual(summary['answered_calls'], 2)\n        self.assertEqual(summary['answer_rate'], 66.67)\n\
    \    \n    def test_build_webhook_url(self):\n        \"\"\"Test webhook URL generation.\"\"\"\n        url = build_twilio_webhook_url(\"\
    https://example.com\", \"biz123\", \"incoming\")\n        self.assertEqual(url, \"https://example.com/webhook/biz123/incoming\"\
    )\n    \n    def test_analyze_sentiment(self):\n        \"\"\"Test sentiment analysis.\"\"\"\n        result = analyze_sentiment(\"\
    This is great service, very helpful\")\n        self.assertGreater(result['sentiment'], 0)\n        self.assertEqual(result['positive_count'],\
    \ 2)\n        \n        result2 = analyze_sentiment(\"This is terrible and awful\")\n        self.assertLess(result2['sentiment'],\
    \ 0)\n        self.assertEqual(result2['negative_count'], 2)\n    \n    def test_format_phone_for_display(self):\n   \
    \     \"\"\"Test phone number formatting.\"\"\"\n        self.assertEqual(format_phone_for_display(\"+14155552671\"),\
    \ \"(415) 555-2671\")\n        self.assertEqual(format_phone_for_display(\"+1234567890\"), \"(234) 567-890\")\n    \n\
    \    def test_setup_business(self):\n        \"\"\"Test business setup functionality.\"\"\"\n        business_data = {\n\
    \            'business_name': 'Test Business',\n            'phone_number': '+14155552671',\n            'business_hours':\
    \ 'Monday: 9:00 AM - 5:00 PM'\n        }\n        result = self.engine.setup_business(business_data)\n        self.assertEqual(result['status'],\
    \ 'created')\n        self.assertTrue('business_id' in result)\n        self.assertTrue('webhook_url' in result)\n   \
    \ \n    def test_create_campaign(self):\n        \"\"\"Test campaign creation.\"\"\"\n        campaign_data = {\n    \
    \        'business_id': 'biz123',\n            'campaign_name': 'Test Campaign',\n            'dialing_mode': 'predictive'\n\
    \        }\n        result = self.engine.create_campaign(campaign_data)\n        self.assertEqual(result['status'], 'draft')\n\
    \        self.assertEqual(result['dialing_mode'], 'predictive')\n    \n    def test_route_call(self):\n        \"\"\"\
    Test call routing.\"\"\"\n        call_data = {\n            'business_id': 'biz123',\n            'caller_number': '+14155552671',\n\
    \            'department': 'sales'\n        }\n        result = self.engine.route_call(call_data)\n        self.assertEqual(result['route_to'],\
    \ 'sales_queue')\n    \n    def test_schedule_callback(self):\n        \"\"\"Test callback scheduling.\"\"\"\n       \
    \ callback_data = {\n            'caller_number': '+14155552671',\n            'preferred_time': '2024-01-01T15:00:00Z',\n\
    \            'queue_position': 3\n        }\n        result = self.engine.schedule_callback(callback_data)\n        self.assertEqual(result['status'],\
    \ 'scheduled')\n        self.assertTrue('callback_id' in result)\n    \n    def test_check_compliance(self):\n       \
    \ \"\"\"Test DNC compliance checking.\"\"\"\n        result = self.engine.check_compliance(\"+14155552671\", \"biz123\"\
    )\n        self.assertIn('compliant', result)\n        self.assertIn('last_checked', result)\n    \n    def test_error_handling(self):\n\
    \        \"\"\"Test error handling in skill engine.\"\"\"\n        with self.assertRaises(ValueError):\n            self.engine.run(\"\
    invalid_action\", {})\n\nif __name__ == '__main__':\n    unittest.main()"
examples:
- description: Load and use the Twilio Expert Multi-Business Call Center skill
  usage: 'from revvel_skills import load_skill

    skill = load_skill(''twilio_call_center'')

    result = skill.execute(params)'
schema_version: '1.0'
